//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
//#include "UIFlow.h"
#include "../../../T800x480/UIFlow.h"

#include "Audio.h"
#include "ide.h"
#include "md_api.h"
#include "IPL_CBMsg.h"
#include "FileSysTsk.h"
#include "MediaRecAPI.h"
#include "IPL_Ctrl.h" // Isiah, implement YUV merge mode of recording func.
#include "Gsensor.h"

#if USE_FILEDB
#include "FileDB.h"
#include "namerule_fileDB.h"
#endif
#define __MODULE__          UIFlowWndMovie
//#define __DBGLVL__ 0        //OFF mode, show nothing
//#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      //*=All
#include "DebugModule.h"
#include "PipView.h"
#include "GxSystem.h"
#include "UsbDevDef.h"

//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_HDR)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticIcon_PIMC)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_GPS)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_LED)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_GSENSOR)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_Lock)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Audio)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_REC)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_TimeLapes)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_ParkingMonitor)
CTRL_LIST_ITEM(UIFlowWndMovie_CarNo_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_ZHCarNo)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_Guide)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Main_PB)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Main_Menu)
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOverTime(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnRAWEncOK(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACPlug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACUnplug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnCustom1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_GsensorTrig(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_ReverseGear(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTouchPanelKey(VControl *, UINT32, UINT32 *);

EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndMovie_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndMovie_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnKeyRight)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW,UIFlowWndMovie_OnBatteryLow)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndMovie_OnKeyMode)
//EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH,UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC,UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_OVERTIME,UIFlowWndMovie_OnOverTime) // the same handling as storage full (may need to show special message)
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL,UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR,UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW,UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_MOVIE_LOOPREC_FULL,UIFlowWndMovie_OnLoopRecFull)
EVENT_ITEM(NVTEVT_CB_RAWENC_OK,UIFlowWndMovie_OnRAWEncOK)
//EVENT_ITEM(IPL_CBMSG_PREVIEWSTABLE,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CALLBACK,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_ZOOM,UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndMovie_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_AC_Plug,UIFlowWndMovie_OnACPlug)
EVENT_ITEM(NVTEVT_AC_UnPlug,UIFlowWndMovie_OnACUnplug)
EVENT_ITEM(NVTEVT_KEY_CUSTOM1,UIFlowWndMovie_OnCustom1)
EVENT_ITEM(NVTEVT_GSENSOR_TRIG,UIFlowWndMovie_GsensorTrig)
EVENT_ITEM(NVTEVT_REVERSEGEAR,UIFlowWndMovie_ReverseGear)
EVENT_ITEM(NVTEVT_TOUCHPANEL_KEY,UIFlowWndMovie_OnTouchPanelKey)

EVENT_END

// Isiah, implement YUV merge mode of recording func.
extern void Movie_IPLChangeCB(UINT32 mode, UINT32 param);

// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_UP | FLGKEY_DOWN)
#define MOVIE_KEY_CONTINUE_MASK     (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
#define MOVIERECORD_KEY_PRESS_MASK  (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
//-----------------------------------------------------------------------------------------
BOOL    g_uiRecordIngMotionDet = FALSE;
static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32 g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
//static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
static volatile BOOL g_ACPlug = FALSE;
static volatile BOOL g_PreviewStable = FALSE;
static volatile BOOL g_PreviewStable_Record = FALSE;
BOOL g_bSpeLockFun = FALSE;
_ALIGNED(4)  GPSDATA gpsdata={0};
BOOL g_bgsensor = FALSE;

extern int SX_TIMER_DET_GSENSOR_ID;

#if (UI_STYLE==UI_STYLE_DRIVER)
extern BOOL m_bACPlug;
#endif

#define UPDATE_FILE  "A:\\logo.jpg"
#define UPDATE_FILE2  "A:\\logo2.jpg"
extern BOOL bCarGuideLineMode ;

#if (_SENSORLIB2_ != _SENSORLIB2_DUMMY_)
void UIFlowMovie_ReverseGearDet(void)
{
    static BOOL u_Carback  = FALSE;
    static UINT32 uiLastPipViewStyle = 0;
	     
    if(GPIOMap_IsReverseGear()&&(bCarGuideLineMode == FALSE))
    {
        uiLastPipViewStyle = PipView_GetStyle();
        //sensor change to sensor2 TV out
        debug_msg("-----------sensoer tv out-------\r\n");
        PipView_SetStyle(PIP_STYLE_2T2F);
        GPIOMap_TurnOnLCDBacklight();
        GxCustom_SetControl(GXCUSTOM_CTRL_AUTOLCDOFF_RESET,0);
        bCarGuideLineMode  = TRUE;
        FlowMovie_UpdateIcons(FALSE);			
        FlowMovie_IconDrawGuideLine();
		
	if(GPIOMap_IsLCDBacklightOn()==FALSE)
	{
		GPIOMap_TurnOnLCDBacklight();
		GxCustom_SetControl(GXCUSTOM_CTRL_AUTOLCDOFF_RESET,0);
	}			
      Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
      /* Init window key mask variables & set key and key released mask */

      Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
      Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
      Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);			
    }
    else if(!GPIOMap_IsReverseGear()&&(bCarGuideLineMode  == TRUE))
    {
        //PipView_SetStyle(PIP_STYLE_2T1B2S);
        PipView_SetStyle(uiLastPipViewStyle);
        bCarGuideLineMode  = FALSE; 
        FlowMovie_UpdateIcons(TRUE);			
		
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
	/* Init window key mask variables & set key and key released mask */
	g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
	g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);			
    } 
}
#endif

BOOL UIFlowMovie_CheckUpdateLogo(void)
{
  BOOL ret = FALSE;
  FST_FILE filehdl = NULL;

     filehdl = FileSys_OpenFile(UPDATE_FILE,FST_OPEN_READ);
     if (filehdl!=NULL)
     {
           FileSys_CloseFile(filehdl);
	     filehdl = FileSys_OpenFile(UPDATE_FILE2,FST_OPEN_READ);
	     if (filehdl!=NULL)
	     {
	        FileSys_CloseFile(filehdl);
	        ret = TRUE;
	     }        
     }


  return ret;
}

BOOL UIFlowWndMovie_IsGsensorTrig(void)
{
	return g_bgsensor;
}
void UIFlowWndMovie_SetGsensorTrigFlag(BOOL En)
{
	g_bgsensor=En;
}
#if (USE_FILEDB==DISABLE)
static void UIFlowWndMovie_DeleteEmptyFolder(void)
{
 SDCFDIRINFO dirinfo;
 char   path[DCF_FULL_FILE_PATH_LEN];
 UINT32 uiMaxFolderID,uiPrevMaxFolderID;
 UINT32 uiStrlen;
 BOOL ret;


    uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);
    // check if folder has file
    ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);
    if (ret)
    {
        while (dirinfo.uiNumOfDcfObj==0)
        {
            DCF_GetDirPath(uiMaxFolderID,path);
            uiStrlen = strlen(path);
            path[uiStrlen-1] = '\0';
            if (FileSys_DeleteDir(path) != FST_STA_OK)
            {
                debug_msg("FileSys_DeleteDir failed\r\n");
            }

            DCF_Refresh();

            uiPrevMaxFolderID = uiMaxFolderID;
            // search another Max Empty folder ID
            uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);

            // break if getting max folder id is always same
            if (uiPrevMaxFolderID == uiMaxFolderID)
                break;
            // check if folder has file
            ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);

            if (ret==FALSE)
              break;
        }
    }
}
#endif

#if (USE_FILEDB==ENABLE)
static void UIFlowWndMovie_OnDeleteOld(void)
{
 UINT32 filenum=0,sec=0;
 UINT32 index = 0;
 PFILEDB_FILE_ATTR  pfile;

    // delete old file and start recording again
    if (SysGetFlag(FL_MOVIE_CYCLIC_REC)!=MOVIE_CYCLICREC_OFF)
    {
        switch(SysGetFlag(FL_MOVIE_CYCLIC_REC))
        {
          case MOVIE_CYCLICREC_3MIN:
             sec=180;
          break;
          case MOVIE_CYCLICREC_5MIN:
             sec=300;
          break;
#if(_MODEL_DSC_==_MODEL_DUAL_790S_)		  
          case MOVIE_CYCLICREC_1MIN:
             sec=00;
          break;
#else
          case MOVIE_CYCLICREC_10MIN:
             sec=600;
          break;
#endif		  
        }

        FileDB_Refresh(0);
        filenum = FileDB_GetTotalFileNum(0);
        while (filenum--)
        {
            pfile = FileDB_SearhFile2(0,index);
            if (!M_IsReadOnly(pfile->attrib))
            {
                if (UIMovRecObj_GetData(RECMOVIE_MAXSECOND)>(sec+10))
                    break;

                FileSys_DeleteFile(pfile->filePath);
                FileDB_DeleteFile(0,index);
            }
            index++;
        }
    }
}
#endif

static void Filesys_dirCB(FIND_DATA *findDir, BOOL *bContinue, UINT16 *cLongname, UINT32 Param)
{
    *bContinue = TRUE;
}
INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiKeyAct;
    UINT32 uiState;
    BOOL   CheckStorageErr = FALSE;


    // flush key event first
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    // if HDMI is inserted, 128MB buffer is not enough for movie recording
    if (KeyScan_GetPlugDev() == PLUG_HDMI)
    {
        return NVTEVT_CONSUME;
    }

    #if (_DUAL_CARD_FUNC_ == ENABLE)
    if ((UI_GetData(FL_CardStatus) == CARD_REMOVED) && (UI_GetData(FL_Card2Status) == CARD_REMOVED))
    #else
    if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
    #endif
    {
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;
    }

    if (paramNum>=3)
    {
        uiState = paramArray[2];
    } else {
        uiState = 0;
    }

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:    
#if(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_)
    case NVTEVT_KEY_CONTINUE:
#endif		
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
            // return directly if dual display is on and 2nd display is HDMI
            // this cause is buffer limitation
            if (SysGetFlag(FL_DualDisp) == DUALDISP_ONBOTH&& IsDualHDMIPlugIn())
            {
                return NVTEVT_CONSUME;
            }
            if (MediaRec_GetStatus() == MEDIAREC_STATUS_OPENED_NOT_RECORD)
            {
                gMovData.State= MOV_ST_REC;
                //#NT#2013/1/28#Philex Lin - begin
                // fix bug that can't record in cyclic and card full case
                if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
                {
                    CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                } else {
                    #if USE_FILEDB
                    if (UI_GetData(FL_IsUseFileDB))
                    {
                       if (FileSys_ScanDir("A:\\DCIM\\",Filesys_dirCB,FALSE)==FST_STA_OK)
                       {
                           CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                       } else {
                          CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                       }
                    }
                    #else
                    CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                    #endif
                }
                if (CheckStorageErr == TRUE)
                //#NT#2013/1/28#Philex Lin - end
                {
                    gMovData.State= MOV_ST_WARNING_MENU;
                    gMovData.SysTimeCount = 0;
                    return NVTEVT_CONSUME;
                }
                if(GetBatteryLevel() == BATTERY_EXHAUSTED)
                {
                    debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
                    return NVTEVT_CONSUME;
                }
                if (FlowMovie_GetSelfTimerID() != NULL_TIMER)
                {
                    FlowMovie_StopRecSelfTimer();
                    return NVTEVT_CONSUME;
                }
/*				
                if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                {
                    g_uiRecordIngMotionDet = TRUE;
                } else {
                    g_uiRecordIngMotionDet = FALSE;
                }
*/
                // Isiah, implement YUV merge mode of recording func.
                if(FlowMovie_RecGetYUVMergeMode()) // Change IPL to movie record mode.
                {
                    IPL_SLEEP_INFO Info;


                    Movie_IPLChangeCB(MEDIAREC_IPLCHG_VIDEO, 0);
                    DBG_DUMP("Changed IPL to movie record mode\r\n");

                    Info.Id = 0;
                    IPL_SetCmd(IPL_SET_SLEEP, (void *)&Info);
                    IPL_WaitCmdFinish();
                }

                FlowMovie_StartRec();
                // start USB detect timer again
                if (g_ACPlug == TRUE)
                    SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);
            }
            break;

        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM: // Isiah, implement YUV merge mode of recording func.
            if ((FlowMovie_GetRecCurrTime() >= 1) || FlowMovie_RecGetYUVMergeMode() ||
                (SysGetFlag(FL_MOVIE_TIMELAPSE_REC) != MOVIE_TIMELAPSEREC_OFF) ||
                (uiState == UIFlowWndMovie_Restart_Rec))
            {
                FlowMovie_StopRec();
                // update ui window icon
		   UIFlowWndMovie_SetGsensorTrigFlag(FALSE);                
                FlowMovie_UpdateIcons(TRUE);

                if (uiState==UIFlowWndMovie_Restart_Rec)
                {
#if ((_MODEL_DSC_ == _MODEL_CARDV_B50_)||(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_))	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif                } else {
                /*
                    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                    {
                        if (g_uiRecordIngMotionDet == TRUE)
                        {
                            g_uiRecordIngMotionDet = FALSE;
                        }
                    }
                    */
                }
            }
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SHUTTER2,paramNum,paramArray);
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        if (0)//((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
        {
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            return NVTEVT_PASS;
        }
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            /* set Digital Zoom interface */
            UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

            gMovData.State |= MOV_ST_ZOOM;
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
             /* set Digital Zoom interface */
             UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

             gMovData.State |= MOV_ST_ZOOM;
             Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

void UIFlowWndMovie_Initparam(void)
{
//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
#if ((USE_FILEDB) && (_FAST_BOOT_REC_FUNC_ == DISABLE))
//#NT#2015/01/21#KS Hung -end
    if (UI_GetData(FL_IsUseFileDB))
    {
       Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FILEID_RESET,0);
    }
#endif
    // The same effect as Photo mode
    //Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,                  1,  SysGetFlag(FL_WB));

    // The other settings
//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
#if (_FAST_BOOT_REC_FUNC_)
    if (FlowMovie_GetFirstBootRecFlag() == FALSE)
    {
        Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);
        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
    }
#else
    //Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);
    //Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
#endif
//#NT#2015/01/21#KS Hung -end

    /* Video resolution setting must be set after other IQ settings */
    {
        UINT32 uiSize;
        uiSize = SysGetFlag(FL_MOVIE_DUAL_REC) ? SysGetFlag(FL_MOVIE_SIZE_DUAL) : SysGetFlag(FL_MOVIE_SIZE);
        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,       1,  uiSize);
    }
    #if (UVC_RECORD_FUNC == ENABLE)
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_IMAGE_RATIO,         1,  SysGetFlag(FL_MOVIE_SIZE));
    #endif

    /* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,          1,  SysGetFlag(FL_MOVIE_CYCLIC_REC));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,          1,  SysGetFlag(FL_MOVIE_MOTION_DET));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DATE_IMPRINT,  1,  SysGetFlag(FL_MOVIE_DATEIMPRINT));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO,         1,  SysGetFlag(FL_MOVIE_AUDIO));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_EV,                  1,  SysGetFlag(FL_EV));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_MOVIE_GSENSOR));

    SysSetFlag(FL_MovieMCTFIndex, MOVIE_MCTF_ON); // forced enable MCTF
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_MCTF,          1,  SysGetFlag(FL_MovieMCTFIndex));
}

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
   static BOOL firstpoweron=TRUE;
   UINT32 KeyCode;
   
    //#NT#2014/11/26#KS Hung -begin
    //GSensor_open();
    //#NT#2014/11/26#KS Hung -end

//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
#if (_FAST_BOOT_REC_FUNC_)
    if (FlowMovie_GetFirstBootRecFlag() == TRUE)
    {
        FlowMovie_SetFirstBootRecFlag(FALSE);
        if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            gMovData.State= MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
            return NVTEVT_CONSUME;
        }
        else if (UI_GetData(FL_CardStatus) == CARD_LOCKED)
        {
            gMovData.State= MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_KEEP);
            return NVTEVT_CONSUME;
        }

        FlowMovie_IconDrawDscMode();
        FlowMovie_IconDrawSize();
        FlowMovie_IconDrawStorage();
        FlowMovie_IconDrawCyclicRec();
        FlowMovie_IconDrawHDR();
        FlowMovie_IconDrawMotionDet();
        FlowMovie_IconDrawDZoom();
        FlowMovie_IconDrawEV();
        FlowMovie_IconDrawDateTime();
        FlowMovie_DrawPIM(FALSE);

        // update g_uiRecordIngMotionDet flag
        if (gUIMotionDetTimerID==NULL_TIMER)
        {
            gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
        }

        if (g_uiDateTimerID == NULL_TIMER)
        {
            g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
        }

        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_MOVIE_GSENSOR));

        return NVTEVT_CONSUME;
    }
#endif
//#NT#2015/01/21#KS Hung -end

    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
    /* Init window key mask variables & set key and key released mask */
    g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);

    UIFlowWndMovie_Initparam();
   if(GxSystem_GetPowerOnSource() == GX_PWRON_SRC_PWR_SW)
   {
	 Gsensor_ClearCrashMode();	     
	 UIFlowWndMovie_SetGsensorTrigFlag(FALSE);    		
   }
    FlowMovie_UpdateIcons(TRUE);

    if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE)
    {
       Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
    }

    // update g_uiRecordIngMotionDet flag
    if (gUIMotionDetTimerID==NULL_TIMER)
    {
        gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
    }

    if (g_uiDateTimerID == NULL_TIMER)
    {
        g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
    }
	
    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
    {
        g_uiRecordIngMotionDet = TRUE;
    } else {
        g_uiRecordIngMotionDet = FALSE;
    }

    // delete empty folder
    #if (USE_FILEDB==DISABLE)
    UIFlowWndMovie_DeleteEmptyFolder();
    #endif

    //#NT#2014/9/3#Philex Lin - begin
    // add time out mechanism to back to movei mode if nothing does in usb mode
    if (SysGetFlag(FL_MOVIE_USBRETURN))
    {
        // clear FL_MOVIE_USBRETURN flag
        SysSetFlag(FL_MOVIE_USBRETURN,FALSE);
        m_bACPlug = TRUE;
        //Ux_PostEvent(NVTEVT_AC_Plug, 0, 0);
    }
    //#NT#2014/9/3#Philex Lin - end    
    if((UIFlowMovie_CheckUpdateLogo()==TRUE)&&(firstpoweron==TRUE))
    {
		UI_UpdateLogoFile();
		firstpoweron=FALSE;
    }
    else
    {
	    if(firstpoweron==TRUE)
	    {
	    	     firstpoweron=FALSE;
		    #if (_MODEL_DSC_ == _MODEL_KERNAL_BOARD_880_)	   
			     if(g_uiRecordIngMotionDet==FALSE)
			     {
		    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
			     }			
		    #else					 
                  GxUSB_UpdateConnectType();
                  if(GxUSB_GetConnectType()!= USB_CONNECT_PC)
                  {
			     if(g_uiRecordIngMotionDet==FALSE)
			     {
					#if ((_MODEL_DSC_ == _MODEL_CARDV_B50_)||(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_))	     
		    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
					#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
		    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);					
					#else
		    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
					#endif
			     }
                  }
		   #endif		  
	    	   SxTimer_SetFuncActive(SX_TIMER_DET_GSENSOR_ID,TRUE);		 
	    }
	    else 
	    {
	    #if (_SENSORLIB2_ != _SENSORLIB2_DUMMY_)		
		    if (Sensor_CheckExtSensor())
		    	{
		    	    if(SysGetFlag(FL_MOVIE_DUAL_REC))
		    	    {
				    PipView_SetStyle(PIP_STYLE_2T1B2S);	
			    }
		    	}
		#endif	
	    }
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if (FlowMovie_GetRecCurrTime() <= 1)
        {
            Delay_DelayMs(1000);
        }
        FlowMovie_StopRec();
        //Ux_SendEvent(&UIFlowWndMovieCtrl,NVTEVT_CB_MOVIE_FINISH,0); // useless
        // temporary solution: wait some time for IPL and display service ready to avoid video buffer corrupted (garbage screen)
        Delay_DelayMs(100);
        break;
    }

    g_bRedLEDOn = FALSE;
    //KeyScan_TurnOffLED(KEYSCAN_LED_RED);

    if (gUIMotionDetTimerID!=NULL_TIMER)
    {
        GxTimer_StopTimer(&gUIMotionDetTimerID);
    }

    if (g_uiDateTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiDateTimerID);
    }
#if  (_SENSORLIB2_ != _SENSORLIB2_DUMMY_)
//#if(_MODEL_DSC_ == _MODEL_DUAL_790S_)
//#else
   //PipView_SetStyle(PIP_STYLE_1T1F);
//#endif
#endif
    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;
    UINT32 uiSelect;
	
    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
        switch(gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_VIEW|MOV_ST_ZOOM:
            // stope timer when entering menu
            if (gUIMotionDetTimerID!=NULL_TIMER)
            {
                GxTimer_StopTimer(&gUIMotionDetTimerID);
            }

            if (g_uiDateTimerID != NULL_TIMER)
            {
                GxTimer_StopTimer(&g_uiDateTimerID);
            }
            // enable shutter2 sound (shutter2 as OK key in menu)
            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
            uiSoundMask |= FLGKEY_SHUTTER2;
            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
            // Set Tab menu to Movie menu
            TM_SetMenu(&gMovieMenu);
            // Open common mix (Item + Option) menu
            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
            gMovData.State = MOV_ST_MENU;
            break;

#if((_MODEL_DSC_ == _MODEL_DUAL_V18_DT_)||(_MODEL_DSC_ == _MODEL_DUAL_790S_)||(_MODEL_DSC_ == _MODEL_DUAL_V18_LYSZ_))	 
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
		    uiSelect=  UI_GetData(FL_MOVIE_AUDIO);
	  	
			      if(uiSelect == MOVIE_AUDIO_OFF)
			      	{
			            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_ON);
			      	}
				else
				{
			            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_OFF);		
				}
		   FlowMovie_IconDrawAudioOnOff();				
		break;
#elif((_MODEL_DSC_ == _MODEL_DUAL_G2800_)||(_MODEL_DSC_ == _MODEL_DUAL_QIZHENG_M1_)||(_MODEL_DSC_ == _MODEL_DUAL_SAIBOSHI_))
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:

		     if(g_bgsensor==FALSE)
		     {
			g_bgsensor = TRUE;     
		       MediaRec_SetCrash();	
			FlowMovie_IconDrawLockFile();
		     }					

	    break;		
#endif
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_MENU,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
//    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSelect;
#if (_MODEL_DSC_ == _MODEL_DUAL_JIACHANGLING_)     
    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:   	
		if(GPIOMap_IsEdogPowerOK()==TRUE)
		{
			debug_msg("Edog power down..\r\n");
			GPIOMap_TurnOnEdog(FALSE);
		}
		else
		{
			debug_msg("Edog power on..\r\n");		
			GPIOMap_TurnOnEdog(TRUE); 
		}
	break;
    }
   return NVTEVT_CONSUME;
#elif((_MODEL_DSC_ == _MODEL_DUAL_V18_DT_ )||(_MODEL_DSC_ == _MODEL_DUAL_V18_LYSZ_))
    uiKeyAct = paramArray[0];
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	
	    switch(gMovData.State)
	    {
	      case MOV_ST_VIEW:
	      case MOV_ST_VIEW|MOV_ST_ZOOM:
	        break;
		 case MOV_ST_REC:
	       case MOV_ST_REC|MOV_ST_ZOOM:
		     if(g_bgsensor==FALSE)
		     {
			g_bgsensor = TRUE;     
		       MediaRec_SetCrash();	
			FlowMovie_IconDrawLockFile();
		     }		
		break;
	    }
	break;
    }
   return NVTEVT_CONSUME;	
#elif(_MODEL_DSC_ == _MODEL_DUAL_790S_)
    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_REC:
            case MOV_ST_REC|MOV_ST_ZOOM:
                if (FlowMovie_GetRecCurrTime() >= 1)
                {
                    UINT32  i, uiDAR[2], uiMovieSize;
                    USIZE   JpegSize[2];

                    FlowMovie_DrawPIM(TRUE);
                    if (UI_GetData(FL_MOVIE_DUAL_REC))
                    {
                        #if 0
                        // only support 1st sensor for raw encoding
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE_DUAL);
                        JpegSize[0].w = GetMovieSizeWidth_2p(0, uiMovieSize);
                        JpegSize[0].h = GetMovieSizeHeight_2p(0, uiMovieSize);
                        uiDAR[0] = GetMovieDispAspectRatio_2p(0, uiMovieSize);
                        if (uiDAR[0] == VIDENC_DAR_16_9)
                        {
                            JpegSize[0].w = (JpegSize[0].h * 16) / 9;
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 1, &JpegSize[0]);
                        #else
                        // support 1st & 2nd path image capture as dual recording
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE_DUAL);
                        for (i = 0; i < 2; i++) // max 2 paths
                        {
                            JpegSize[i].w = GetMovieSizeWidth_2p(i, uiMovieSize);
                            JpegSize[i].h = GetMovieSizeHeight_2p(i, uiMovieSize);
                            uiDAR[i] = GetMovieDispAspectRatio_2p(i, uiMovieSize);
                            if (uiDAR[i] == VIDENC_DAR_16_9)
                            {
                                JpegSize[i].w = (JpegSize[i].h * 16) / 9;
                            }
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, &JpegSize[0], &JpegSize[1]);
                        #endif
                    }
                    else
                    {
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                        JpegSize[0].w = GetMovieSizeWidth(uiMovieSize);
                        JpegSize[0].h = GetMovieSizeHeight(uiMovieSize);
                        uiDAR[0] = GetMovieDispAspectRatio(uiMovieSize);
                        if (uiDAR[0] == VIDENC_DAR_16_9)
                        {
                            JpegSize[0].w = (JpegSize[0].h * 16) / 9;
                        } 
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 1, &JpegSize[0]);
                    }
                }
                break;
         }
         break;
    }

#elif ((_MODEL_DSC_ == _MODEL_DUAL_G2800_)||(_MODEL_DSC_ == _MODEL_DUAL_QIZHENG_M1_)||(_MODEL_DSC_ == _MODEL_DUAL_SAIBOSHI_))	 
    uiKeyAct = paramArray[0];
    uiSelect=  UI_GetData(FL_MOVIE_AUDIO);
    debug_msg("UIFlowwwndMovie Key Down..%d\r\n",uiSelect);

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	  	
	      if(uiSelect == MOVIE_AUDIO_OFF)
	      	{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_ON);
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_ON);				
	      	}
		else
		{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_OFF);		
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_OFF);					
		}
	break;		
    }
   return NVTEVT_CONSUME;		
#elif(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_)
    uiKeyAct = paramArray[0];
    switch (uiKeyAct) 
    {
    case NVTEVT_KEY_PRESS:	
    #if (_SENSORLIB2_ != _SENSORLIB2_DUMMY_)			
         debug_msg("-->System_OnPipSetting : %d..\r\n",PipView_GetStyle());	
	    if (Sensor_CheckExtSensor())
	    	{
		    switch(PipView_GetStyle())
		    {    
			    case PIP_STYLE_1T1F://PIP_STYLE_1T1B2S:
				PipView_SetStyle(PIP_STYLE_1T1S2B);  //A+B    A small		
				break;
				
			    case PIP_STYLE_1T1S2B:
				PipView_SetStyle(PIP_STYLE_2T2F); //only B
				break;
				
			    case PIP_STYLE_2T2F:
				PipView_SetStyle(PIP_STYLE_2T1B2S); //A+B  B small 		
				break;

			    case PIP_STYLE_2T1B2S:
				PipView_SetStyle(PIP_STYLE_1T1F);// only A 		
				break;		
		    }    
	    	}
     #endif		
	break;
    case NVTEVT_KEY_CONTINUE:	
             uiSelect=  UI_GetData(FL_MOVIE_AUDIO);
	      if(uiSelect == MOVIE_AUDIO_OFF)
	      	{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_ON);
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_ON);				
	      	}
		else
		{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_OFF);		
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_OFF);					
		}		
	break;	 
    	}   
#else
    uiKeyAct = paramArray[0];
    uiSelect=  UI_GetData(FL_MOVIE_AUDIO);
    debug_msg("UIFlowwwndMovie Key Down..%d\r\n",uiSelect);

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	  	
	      if(uiSelect == MOVIE_AUDIO_OFF)
	      	{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_ON);
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_ON);				
	      	}
		else
		{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_OFF);		
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_OFF);					
		}
	break;		
    }
   return NVTEVT_CONSUME;
#endif   
   //return UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiEV;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:
                uiEV = SysGetFlag(FL_EV);
                if (uiEV==EV_N20)
                {
                    SysSetFlag(FL_EV,EV_P20);
                } else {
                    SysSetFlag(FL_EV,++uiEV);
                }
                Ux_SendEvent(&CustomMovieObjCtrl,NVTEVT_EXE_MOVIE_EV,1, SysGetFlag(FL_EV));
                FlowMovie_IconDrawEV();
            break;
            case MOV_ST_REC:
                if(SysGetFlag(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF && FlowMovie_GetRecCurrTime() >= 1)
                {
                    #if (0)//(PRJ == APC3)
                        g_bSpeLockFun = TRUE;
                        FlowMovie_StopRec();
                        Ux_SendEvent(pCtrl,NVTEVT_CB_MOVIE_FINISH,1,UIFlowWndMovie_Restart_Rec);
                    #endif
                }
            break;
         }
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_REC:
            case MOV_ST_REC|MOV_ST_ZOOM:
                if (FlowMovie_GetRecCurrTime() >= 1)
                {
                    UINT32  i, uiDAR[2], uiMovieSize;
                    USIZE   JpegSize[2];

                    FlowMovie_DrawPIM(TRUE);
                    if (UI_GetData(FL_MOVIE_DUAL_REC))
                    {
                        #if 0
                        // only support 1st sensor for raw encoding
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE_DUAL);
                        JpegSize[0].w = GetMovieSizeWidth_2p(0, uiMovieSize);
                        JpegSize[0].h = GetMovieSizeHeight_2p(0, uiMovieSize);
                        uiDAR[0] = GetMovieDispAspectRatio_2p(0, uiMovieSize);
                        if (uiDAR[0] == VIDENC_DAR_16_9)
                        {
                            JpegSize[0].w = (JpegSize[0].h * 16) / 9;
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 1, &JpegSize[0]);
                        #else
                        // support 1st & 2nd path image capture as dual recording
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE_DUAL);
                        for (i = 0; i < 2; i++) // max 2 paths
                        {
                            JpegSize[i].w = GetMovieSizeWidth_2p(i, uiMovieSize);
                            JpegSize[i].h = GetMovieSizeHeight_2p(i, uiMovieSize);
                            uiDAR[i] = GetMovieDispAspectRatio_2p(i, uiMovieSize);
                            if (uiDAR[i] == VIDENC_DAR_16_9)
                            {
                                JpegSize[i].w = (JpegSize[i].h * 16) / 9;
                            }
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, &JpegSize[0], &JpegSize[1]);
                        #endif
                    }
                    else
                    {
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                        JpegSize[0].w = GetMovieSizeWidth(uiMovieSize);
                        JpegSize[0].h = GetMovieSizeHeight(uiMovieSize);
                        uiDAR[0] = GetMovieDispAspectRatio(uiMovieSize);
                        if (uiDAR[0] == VIDENC_DAR_16_9)
                        {
                            JpegSize[0].w = (JpegSize[0].h * 16) / 9;
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 1, &JpegSize[0]);
                    }
                }
                break;
         }
         break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiSoundMask;

    switch (gMovData.State)
    {
    case MOV_ST_WARNING_MENU:
         //#NT#2015/01/21#KS Hung -begin
         #if (_FAST_BOOT_REC_FUNC_)
         if ((UI_GetData(FL_CardStatus) == CARD_REMOVED) || (UI_GetData(FL_CardStatus) == CARD_LOCKED))
         {
             FlowMovie_UpdateIcons(TRUE);
             gMovData.State = MOV_ST_VIEW;
             break;
         }
         #endif
         //#NT#2015/01/21#KS Hung -end
         if(paramNum > 0)
           {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Create Menu window */
                    gMovData.State = MOV_ST_MENU;
                    TM_SetMenu(&gMovieMenu);
                    Ux_OpenWindow(&MenuCommonItemCtrl, 0);
                    return NVTEVT_CONSUME;
                }
            }
            gMovData.State = MOV_ST_VIEW;
        break;

    case MOV_ST_MENU:
        // disable shutter2 sound
        uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
        uiSoundMask &= ~FLGKEY_SHUTTER2;
        Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

         g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
         g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
         Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
         Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
#if 1//(_MODEL_DSC_==_MODEL_DUAL_790S_)
	    if(GPIOMap_IsReverseGear()==TRUE) 
	    {
	        	Ux_PostEvent(NVTEVT_REVERSEGEAR, 1,TRUE);
	    }	
	    else
	    {
         	FlowMovie_UpdateIcons(TRUE);
	    }
#else			 
         FlowMovie_UpdateIcons(TRUE);
#endif
         // start timer again when exiting menu
         if (gUIMotionDetTimerID==NULL_TIMER)
         {
           gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
         }

         if (g_uiDateTimerID == NULL_TIMER)
         {
           g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
         }

         gMovData.State = MOV_ST_VIEW;
        break;
    }

    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
    {
        g_uiRecordIngMotionDet = TRUE;
    } else {
        g_uiRecordIngMotionDet = FALSE;
    }

    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_MODEL_DSC_ == _MODEL_CARDV_B50_)
    UINT32  uiKeyAct;
    uiKeyAct = paramArray[0];
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
	      if((KeyScan_GetPlugDev() != 1)&&(KeyScan_GetPlugDev() != 2))
	     	{
	     		if(GPIOMap_IsLCDBacklightOn()==TRUE)
			GPIOMap_TurnOffLCDBacklight();
			else
			GPIOMap_TurnOnLCDBacklight();				
	     	}	  	
	  break;
    }
    return NVTEVT_CONSUME;
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    UINT32  uiKeyAct;
    uiKeyAct = paramArray[0];
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
    		switch(gMovData.State)
	    {
	      case MOV_ST_VIEW:
	      case MOV_ST_VIEW|MOV_ST_ZOOM:
	       break;
		case MOV_ST_REC:
	      case MOV_ST_REC|MOV_ST_ZOOM:
		     if(g_bgsensor==FALSE)
		     {
			g_bgsensor = TRUE;     
		       MediaRec_SetCrash();	
			FlowMovie_IconDrawLockFile();
		     }		
		break;
	    }
	break;
    	}	
    return NVTEVT_CONSUME;	
#else
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
#endif
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomIn(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomOut(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSelect;
	
    uiKeyAct = paramArray[0];
#if((_MODEL_DSC_ == _MODEL_CARDV_B50_))
    	return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
#elif(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_)
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	  
	    switch(gMovData.State)
	    {
	      case MOV_ST_VIEW:
	      case MOV_ST_VIEW|MOV_ST_ZOOM:	  	
    			return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
		break;
		 case MOV_ST_REC:
	       case MOV_ST_REC|MOV_ST_ZOOM:
		     if(g_bgsensor==FALSE)
		     {
			g_bgsensor = TRUE;     
		       MediaRec_SetCrash();	
			FlowMovie_IconDrawLockFile();
		     }		
		break;		
	    }
	break;
	case NVTEVT_KEY_CONTINUE:
    		return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);			    
	break;	
    }
#elif(_MODEL_DSC_ == _MODEL_DUAL_JIACHANGLING_)

    uiSelect=  UI_GetData(FL_MOVIE_AUDIO);
    debug_msg("UIFlowwwndMovie Key Down..%d\r\n",uiSelect);

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	  	
	      if(uiSelect == MOVIE_AUDIO_OFF)
	      	{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_ON);
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_ON);				
	      	}
		else
		{
	            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_OFF);		
    		     UxState_SetData(&UIFlowWndMovie_Status_AudioCtrl,STATE_CURITEM,MOVIE_AUDIO_OFF);					
		}
	break;		
    }    
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    		return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray); 
#elif(_MODEL_DSC_ == _MODEL_DUAL_NAZHIDA_)

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	
	    switch(gMovData.State)
	    {
	      case MOV_ST_VIEW:
	      case MOV_ST_VIEW|MOV_ST_ZOOM:
	        break;
		 case MOV_ST_REC:
	       case MOV_ST_REC|MOV_ST_ZOOM:
		     if(g_bgsensor==FALSE)
		     {
			g_bgsensor = TRUE;     
		       MediaRec_SetCrash();	
			FlowMovie_IconDrawLockFile();
		     }		
		break;
	    }
	break;
    }
 #else    
	    switch (uiKeyAct) 
	    {
	    case NVTEVT_KEY_PRESS:	
	    #if (_SENSORLIB2_ != _SENSORLIB2_DUMMY_)			
	         debug_msg("-->System_OnPipSetting : %d..\r\n",PipView_GetStyle());	
		    if (Sensor_CheckExtSensor())
		    	{
			    switch(PipView_GetStyle())
			    {    
				    case PIP_STYLE_1T1F://PIP_STYLE_1T1B2S:
					PipView_SetStyle(PIP_STYLE_1T1S2B);  //A+B    A small		
					break;
					
				    case PIP_STYLE_1T1S2B:
					PipView_SetStyle(PIP_STYLE_2T2F); //only B
					break;
					
				    case PIP_STYLE_2T2F:
					PipView_SetStyle(PIP_STYLE_2T1B2S); //A+B  B small 		
					break;

				    case PIP_STYLE_2T1B2S:
					PipView_SetStyle(PIP_STYLE_1T1F);// only A 		
					break;		
			    }    
		    	}
	#endif		
		break;
	    	}
#endif	
    return NVTEVT_CONSUME;    
}
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 static volatile BOOL bBatteryOn = FALSE;
    if(bCarGuideLineMode==TRUE)
	return;
    UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsACIn())
    {
        bBatteryOn = !bBatteryOn;
        if (bBatteryOn==FALSE)
            UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,UIFlowWndMovie_Status_battery_ICON_TRANSPAENT);
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    } else {
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;
	 case MOV_ST_REC:
       case MOV_ST_REC|MOV_ST_ZOOM:
#if ((_MODEL_DSC_ == _MODEL_DUAL_V18_DT_)||(_MODEL_DSC_ == _MODEL_DUAL_V18_LYSZ_))	
//do nothing

#elif ((_MODEL_DSC_ == _MODEL_DUAL_G2800_)||(_MODEL_DSC_ == _MODEL_DUAL_QIZHENG_M1_)||(_MODEL_DSC_ == _MODEL_DUAL_SAIBOSHI_))
//do nothing
#else
	     if(g_bgsensor==FALSE)
	     {
		g_bgsensor = TRUE;     
	       MediaRec_SetCrash();	
		FlowMovie_IconDrawLockFile();
	     }		
#endif		 
	break;
    }
    return NVTEVT_CONSUME;
}
//#NT#2014/06/30#Hideo Lin -begin
//#NT#Don't need to handle this event; this event will be issued after recording stop,
//#NT#and cause handling previous one if shutter key was pressed frequently.
//#NT#In fact, the handling codes here are almost duplicated with other events...
#if 0
INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiFolderId, uiFileId;
    BOOL    CheckStorageErr;
    //UINT32  gUIAviRecMaxTime;

    switch (gMovData.State)
    {
      case MOV_ST_REC:
      case MOV_ST_REC|MOV_ST_ZOOM:
            #if 0
            if(UIStorageCheck(STORAGE_CHECK_FULL, &(gUIAviRecMaxTime)) != TRUE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);
            }
            #endif
            //gMovData.State = MOV_ST_VIEW;
            g_uiRecordIngMotionDet = FALSE;
            //#NT#2012/10/23#Philex Lin - begin
            // enable auto power off/USB detect timer
            KeyScan_EnableMisc(TRUE);
            //#NT#2012/10/23#Philex Lin - end
            FlowMovie_IconDrawMaxRecTime();
            UxState_SetData(&UIFlowWndMovie_Status_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_REC_ICON_TRANSPAENT);

            //if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
            if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
            {
                CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
            } else {
                CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
            }
            if (CheckStorageErr == FALSE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);

                FlowMovie_UpdateIcons(TRUE);
                Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            }
            break;

        //The flow here may be only for APC3 stop record than lock file function.
        //To be careful that gMovData have changed in UIFlowMovie_Stop.
        case MOV_ST_VIEW:
            #if (0)//(PRJ == APC3)
            if (paramNum)
            {
                if (paramArray[0]==UIFlowWndMovie_Restart_Rec)
                {
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                }
            }
            #endif
            break;
    }

    return NVTEVT_CONSUME;
}
#endif
//#NT#2014/06/30#Hideo Lin -end
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  static volatile BOOL bRecordShow = FALSE;
  static BOOL bGsensorTrig=FALSE;
  
  UINT32 uiRecSecond, uiCyclicRecTime;

    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        bRecordShow = !bRecordShow;
       if(bCarGuideLineMode==FALSE)
    	{
        if (bRecordShow)
        {
		FlowMovie_IconDrawRecording();
	 }
        else
        {
		FlowMovie_IconHideRecording();
        }
       }
	   
        if (paramNum)
        {
            //UINT32 uiRecSecond, uiCyclicRecTime;

            uiRecSecond = paramArray[0];
            uiCyclicRecTime = Movie_GetCyclicRecTime();
            if (uiRecSecond > uiCyclicRecTime)
            {
                uiRecSecond -= uiCyclicRecTime;
            }
            FlowMovie_SetRecCurrTime(uiRecSecond);

            //#NT#2014/4/14#Philex Lin - begin
            // add cyclic recording with time lapse function
            #if USE_FILEDB
            if (SysGetFlag(FL_MOVIE_TIMELAPSE_REC)!=MOVIE_TIMELAPSEREC_OFF)
            {
                if (SysGetFlag(FL_MOVIE_CYCLIC_REC)!=MOVIE_CYCLICREC_OFF)
                {
                    if (paramArray[0]==uiCyclicRecTime)
                    {
                        //if (FlowMovie_GetRecCurrTime() >= 1 || FlowMovie_RecGetYUVMergeMode())
                        {
                            // stop recording
                            FlowMovie_StopRec();

                            // delete old files if disk is almost full
                            UIFlowWndMovie_OnDeleteOld();

                            // start recording again
#if((_MODEL_DSC_ == _MODEL_CARDV_B50_)||(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_))	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
                        }
                    }
                }
            }
            #endif
            //#NT#2014/4/14#Philex Lin - end
        }
        if(bCarGuideLineMode==FALSE)
        {        
      		FlowMovie_IconDrawRecTime();
      	  }
	  if(Gsensor_GetCrashMode()==TRUE)
	  {
		if((UIFlowWndMovie_IsGsensorTrig()==FALSE)&&(uiRecSecond==1))	
		{
			g_bgsensor = TRUE;     
		      MediaRec_SetCrash();	
		      Gsensor_ClearCrashMode();	     			  
			FlowMovie_IconDrawLockFile();
			bGsensorTrig=TRUE;
		}
	  }
	  
      if((uiRecSecond==20)&&(bGsensorTrig==TRUE))//20 sensonds
      	{
		 UIFlowWndMovie_SetGsensorTrigFlag(FALSE);    
  		 FlowMovie_IconHideLockFile();	
		 bGsensorTrig=FALSE;
		 
                FlowMovie_StopRec();
                if ( FALSE == AE_Wait_Stable(3, 60) )
                    DBG_ERR("Movie one seocond EVENT: AE do not stable\r\n");
		#if(_MODEL_DSC_ == _MODEL_CARDV_B50_)							
		   	Ux_PostEvent(NVTEVT_SYSTEM_SHUTDOWN, 1, 0);
		#else
                  GxUSB_UpdateConnectType();
                  if(GxUSB_GetConnectType()== USB_CONNECT_NONE)
                  {			
		   	Ux_PostEvent(NVTEVT_SYSTEM_SHUTDOWN, 1, 0);
                  }                  
		    else
		    {
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
		    }
		#endif	
	}		
	  
        if (UxCtrl_IsShow(&UIFlowWndMovie_StaticIcon_PIMCCtrl))
            FlowMovie_DrawPIM(FALSE);
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnLoopRecFull(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnOverTime(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  BOOL    isNeedRecordAgain=FALSE;

    if (gMovData.State&MOV_ST_REC)
    {
        isNeedRecordAgain = TRUE;
    } else {
        isNeedRecordAgain = FALSE;
    }
    FlowMovie_StopRec();
    //#NT#2012/10/23#Philex Lin - begin
    //enable auto power off/USB detect timer
    KeyScan_EnableMisc(TRUE);
    //#NT#2012/10/23#Philex Lin - end

        if (TRUE==isNeedRecordAgain)
        {
#if((_MODEL_DSC_ == _MODEL_CARDV_B50_)||(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_))	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
        }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if ((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM)))
    {
        FlowMovie_StopRec();
        #if (_DUAL_CARD_FUNC_ == ENABLE)
        if ((UI_GetData(FL_CardStatus) == CARD_LOCKED) || (UI_GetData(FL_Card2Status) == CARD_LOCKED))
        #else
        if (UI_GetData(FL_CardStatus) == CARD_LOCKED)
        #endif
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
        else
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
    }
    else
    {
        Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // trigger re-start encoding
    #if 0
    return UIFlowWndMovie_OnExeRecord(pCtrl, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    #else
    Movie_SetSDSlow(TRUE);
#if ((_MODEL_DSC_ == _MODEL_CARDV_B50_)||(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_))
    Ux_PostEvent(NVTEVT_KEY_UP, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    	 Ux_PostEvent(NVTEVT_KEY_UP, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
    	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif	

    return NVTEVT_CONSUME;
    #endif
}
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_StopRec();
    KeyScan_EnableMisc(TRUE);
    //gMovData.State = MOV_ST_VIEW;
    gMovData.State= MOV_ST_WARNING_MENU;
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL,FLOWWRNMSG_TIMER_2SEC);
    FlowMovie_IconDrawMaxRecTime();
    return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    ide_enable_video(IDE_VIDEOID_1);
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnRAWEncOK(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  CHAR Path[60];

    RawEnc_GetPath(&Path[0]);
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_IconDrawDZoom();
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if (_DUAL_CARD_FUNC_)
    if (SysGetFlag(FL_CardChange) == CARD_CHANGE_YES)
    {
        SysSetFlag(FL_CardChange, CARD_CHANGE_NO);
        SysSetFlag(FL_MOVIE_CYCLIC_REC,             MOVIE_CYCLICREC_3MIN);
        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_CYCLIC_REC, 1, SysGetFlag(FL_MOVIE_CYCLIC_REC));
        FlowMovie_IconDrawMaxRecTime();
        FlowMovie_IconDrawCyclicRec();

        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    }
    #endif

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiEvent;

    if (paramNum>0)
    {
        uiEvent = paramArray[0];
        if (uiEvent != NVTEVT_ALGMSG_PREVIEW_STABLE)
            return NVTEVT_CONSUME;
    } else {
        return NVTEVT_CONSUME;
    }

    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    g_PreviewStable = TRUE;
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_UpdateIcons(TRUE);

    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyRelease);
    return NVTEVT_CONSUME;
}
#if (GPS_FUNCTION == ENABLE)
inline static void  UIFlowWndMovie_UpdateSpeedData(void)
{
  RMCINFO RMCInfo;

      GPSRec_GetRMCDate(&RMCInfo);
      memcpy(&(gpsdata.rmcinfo),&RMCInfo,sizeof(RMCINFO));
      #if 0
      debug_msg("lati:%1f, NS:%c, longi:%1f,EW:%c\r\n",gpsdata.rmcinfo.Latitude,gpsdata.rmcinfo.NSInd,gpsdata.rmcinfo.Longitude,gpsdata.rmcinfo.EWInd);
      #endif
}
#endif

INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiEvent;
	
    uiEvent = paramNum ? paramArray[0] : 0;

    switch(uiEvent)
    {
    case NVTEVT_05SEC_TIMER:
        // Motion Detect function
        //debug_msg("motion det:%d\r\n",g_uiRecordIngMotionDet);
        if (g_uiRecordIngMotionDet==TRUE)
        {
            static UINT32  uiMotionDetGo = 0;
            static UINT32  uiMotionDetStop = 0;

            if (MD_Process()==TRUE)
            {
                 uiMotionDetGo++;
                 if (uiMotionDetGo>=2)
                 {
                    uiMotionDetStop=0;
                    if (!((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM))))
                    {
                        // reset uiMotionDetGo
                        uiMotionDetGo = 0;
                        // press enter key to record video
#if ((_MODEL_DSC_ == _MODEL_CARDV_B50_)||(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_))	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
                    }
                 }
            } else {
                uiMotionDetStop++;
                if (uiMotionDetStop>=2) // 1 sec
                {
                    uiMotionDetGo=0;
                }
                if (uiMotionDetStop>=20) // 10 Sec
                {
                    uiMotionDetStop = 0;
                    switch(gMovData.State)
                    {
                      case MOV_ST_REC:
                      case MOV_ST_REC|MOV_ST_ZOOM:
                        // stop recording
                        if (FlowMovie_GetRecCurrTime() >= 1)
                        {
 				  UIFlowWndMovie_SetGsensorTrigFlag(FALSE);    
 		  		  FlowMovie_IconHideLockFile();	                        
                            FlowMovie_StopRec();
                            if ( FALSE == AE_Wait_Stable(3, 60) )
                                DBG_ERR("Motion Detection: AE do not stable\r\n");
                        }
                        break;
                    }
                }
            }
        }

        //get GPS/GSensor Data
        //#NT#2013/3/20#Philex Lin-begin
#if(_MODEL_DSC_!=_MODEL_KERNAL_BOARD_880_)	        
        #if (GPS_FUNCTION == ENABLE)
        UIFlowWndMovie_UpdateSpeedData();
        #endif
#endif		
        //#NT#2013/3/20#Philex Lin-end
        break;

    case NVTEVT_1SEC_TIMER:
		/*
#if (_SENSORLIB2_ != _SENSORLIB2_DUMMY_)		
	  UIFlowMovie_ReverseGearDet();
#endif
*/
        FlowMovie_OnTimer1SecIndex();
        // Isiah, implement YUV merge mode of recording func.
        if(MediaRec_IsRecording() && FlowMovie_RecGetYUVMergeMode())
        {
            MEDIAREC_READYBUF_INFO readyInfo;
            IPL_IME_BUF_ADDR CurInfo;
            IPL_SLEEP_INFO Info;

            FlowMovie_RecYUVMergeCounterInc();
            if(FlowMovie_RecGetYUVMergeRecCounter() < FlowMovie_RecGetYUVMergeRecInterval())
            {
                break;
            }
            else // reset counter;
            {
                FlowMovie_RecSetYUVMergeRecCounter(0);
            }

            Info.Id = 0;
            IPL_SetCmd(IPL_SET_WAKEUP, (void *)&Info);
            IPL_WaitCmdFinish();
            // Wait until AE/AWB are stable.
            IPC_WaitVD(FALSE,IPL_ID_1);
            IPC_WaitVD(FALSE,IPL_ID_1);
            IPC_WaitVD(FALSE,IPL_ID_1);

            CurInfo.Id = IPL_ID_1;
            IPL_GetCmd(IPL_GET_IME_CUR_BUF_ADDR, (void *)&CurInfo);

            readyInfo.y = CurInfo.ImeP1.PixelAddr[0];
            readyInfo.cb = CurInfo.ImeP1.PixelAddr[1];
            //readyInfo.cr = CurInfo.ImeP1.PixelAddr[2];
            readyInfo.cr = CurInfo.ImeP1.PixelAddr[1]; // UV pack
            readyInfo.y_lot = CurInfo.ImeP1.Ch[0].LineOfs;
            readyInfo.uv_lot = CurInfo.ImeP1.Ch[1].LineOfs;
            readyInfo.uiBufID = CurInfo.ImeP1.PixelAddr[2]; // for IME ready buffer check
            MediaRec_GiveYUV(&readyInfo);

            // Wait 40 ms to ensure encode finished.
            Delay_DelayMs(40);

            Info.Id = 0;
            IPL_SetCmd(IPL_SET_SLEEP, (void *)&Info);
            IPL_WaitCmdFinish();
        }
        else if (g_PreviewStable_Record == FALSE)
        {
            if ((g_ACPlug==TRUE)&&(g_PreviewStable == TRUE))
            {
                g_PreviewStable_Record = TRUE;
#if((_MODEL_DSC_ == _MODEL_CARDV_B50_)||(_MODEL_DSC_== _MODEL_DUAL_NAZHIDA_))	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
            }
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_TIMER,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACPlug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = TRUE;
    // start record if receiving preview stable event
    if ((g_PreviewStable == TRUE)&&(g_PreviewStable_Record == FALSE))
    {
        g_PreviewStable_Record = TRUE;
        //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACUnplug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = FALSE;
    //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnCustom1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

#if (_MODEL_DSC_ == _MODEL_CARDV_B50_)
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	    
              switch(gMovData.State)
 	       {
 		   case MOV_ST_REC:
 	          case MOV_ST_REC|MOV_ST_ZOOM:	  	
		     if(g_bgsensor==FALSE)
		     {
			g_bgsensor = TRUE;     
		       MediaRec_SetCrash();	
			FlowMovie_IconDrawLockFile();
		     }			
		    break;
              }
	  break;
    }
#elif((_MODEL_DSC_ == _MODEL_DUAL_F6PLUS_)||(_MODEL_DSC_ == _MODEL_DUAL_V18_DT_)\
	||(_MODEL_DSC_ == _MODEL_DUAL_HLYD_)||(_MODEL_DSC_ == _MODEL_DUAL_G2800_)\
	||(_MODEL_DSC_ ==_MODEL_CARDV_S650_)||(_MODEL_DSC_ == _MODEL_DUAL_HLYD_MUBEN_)\
	||(_MODEL_DSC_ == _MODEL_DUAL_QIZHENG_M1_)||(_MODEL_DSC_ == _MODEL_DUAL_790S_)\
	||(_MODEL_DSC_ == _MODEL_DUAL_V18_LYSZ_)||(_MODEL_DSC_==_MODEL_DUAL_89M3_)\
	||(_MODEL_DSC_ == _MODEL_DUAL_SAIBOSHI_))
    switch (uiKeyAct)
    { 
      case NVTEVT_KEY_PRESS:
	      if((KeyScan_GetPlugDev() != 1)&&(KeyScan_GetPlugDev() != 2))
	     	{
	     		if(GPIOMap_IsLCDBacklightOn()==TRUE)
			GPIOMap_TurnOffLCDBacklight();
			else
			GPIOMap_TurnOnLCDBacklight();	 			
	     	}	  	
	  break;
    }	
#elif (_MODEL_DSC_ == _MODEL_DUAL_F5_)	
   debug_msg("System_OnPipSetting : %d..\r\n",PipView_GetStyle());

    switch (uiKeyAct) 
    {
    case NVTEVT_KEY_PRESS:	
	    switch(PipView_GetStyle())
	    {
		    //case PIP_STYLE_1T1F:
			//PipView_SetStyle(PIP_STYLE_1T1B2S);
			//break;
		    case PIP_STYLE_1T1F://PIP_STYLE_1T1B2S:
			PipView_SetStyle(PIP_STYLE_1T1S2B);
			break;
		    case PIP_STYLE_1T1S2B:
			PipView_SetStyle(PIP_STYLE_2T2F);
			break;
		    case PIP_STYLE_2T2F:
			PipView_SetStyle(PIP_STYLE_2T1B2S);
			break;
		    case PIP_STYLE_2T1B2S:
			PipView_SetStyle(PIP_STYLE_2T1S2B);
			break;
		    case PIP_STYLE_2T1S2B:
			PipView_SetStyle(PIP_STYLE_1T1F);
			break;		
	    }    
	break;
    	}	
#elif(_MODEL_DSC_ == _MODEL_DUAL_NAZHIDA_)	
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	 
              switch(gMovData.State)
 	       {
 		   case MOV_ST_REC:
 	          case MOV_ST_REC|MOV_ST_ZOOM: 	       
 		   case MOV_ST_VIEW:
 	          case MOV_ST_VIEW|MOV_ST_ZOOM:
		      if((KeyScan_GetPlugDev() != 1)&&(KeyScan_GetPlugDev() != 2))
		     	{
		     		if(GPIOMap_IsLCDBacklightOn()==TRUE)
				GPIOMap_TurnOffLCDBacklight();
				else
				GPIOMap_TurnOnLCDBacklight();	 			
		     	}			  	
			break; 	       
               }
	  break;
    }
#else

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	    
	    switch(UI_GetData(FL_LEDSET))
	    {
	        case LED_OFF:
			UI_SetData(FL_LEDSET,LED_ON);	
			GPIOMap_TurnOnWhiteLight();						
	 		break;
		 case LED_ON:
			UI_SetData(FL_LEDSET,LED_OFF);	
			GPIOMap_TurnOffWhiteLight();				 	
		 	break;
		 default:
		 	break;
	    } 	  	
        FlowMovie_IconDrawLED();		
	  break;
    }
#endif
/*
    if(SysGetFlag(FL_MOVIE_GSENSOR) !=GSENSOR_OFF)
    {
        if ( (gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT) )
        {
            MediaRec_SetCrash();
        }
        else if(gMovData.State == MOV_ST_VIEW)
        {
            MediaRec_SetCrash();
            Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS, 0, 0);
        }
        debug_err(("*********MediaRec_SetCrash1()**********\n\r"));
    }
    */
   
	return NVTEVT_CONSUME;
}
//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
INT32 UIFlowWndMovie_OnFastBootRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_FAST_BOOT_REC_FUNC_)
    static BOOL bOnceFastRec = FALSE;

    if ( (FlowMovie_GetFirstBootRecFlag() == FALSE) && (bOnceFastRec == TRUE))
    {
        return NVTEVT_CONSUME;
    }

    UIFlowWndMovie_Initparam();
    FlowMovie_StartRec();

    g_PreviewStable = TRUE;
    g_PreviewStable_Record = TRUE;

    System_OnVideoFastBootInit2();
    Display_SetEnable(LAYER_VDO1, TRUE);
    UI_UIWndDispatchMessage(TRUE);
    Ux_OpenWindow((VControl *)(&UIFlowWndMovieCtrl), 0);
    GxVideo_SetDeviceCtrl(DOUT1, DISPLAY_DEVCTRL_BACKLIGHT, TRUE);
    bOnceFastRec = TRUE;
#endif
    return NVTEVT_CONSUME;
}
//#NT#2015/01/21#KS Hung -end


INT32 UIFlowWndMovie_GsensorTrig(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
     if(g_bgsensor==FALSE)
     {
	g_bgsensor = TRUE;     
       MediaRec_SetCrash();	
	FlowMovie_IconDrawLockFile();
     }	 	
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_ReverseGear(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    static UINT32 uiLastPipViewStyle = 0;
    UINT32  uiReverseGear;
    uiReverseGear = paramNum ? paramArray[0] : 0;
	
    if((uiReverseGear==TRUE)&&(bCarGuideLineMode == FALSE))
    {
        uiLastPipViewStyle = PipView_GetStyle();
        //sensor change to sensor2 TV out
        debug_msg("---Reverse gear shitf, TRUE..\r\n");
        PipView_SetStyle(PIP_STYLE_2T2F);
        GPIOMap_TurnOnLCDBacklight();
        GxCustom_SetControl(GXCUSTOM_CTRL_AUTOLCDOFF_RESET,0);
        bCarGuideLineMode  = TRUE;
        FlowMovie_UpdateIcons(FALSE);			
        FlowMovie_IconDrawGuideLine();
		
	if(GPIOMap_IsLCDBacklightOn()==FALSE)
	{
		GPIOMap_TurnOnLCDBacklight();
		GxCustom_SetControl(GXCUSTOM_CTRL_AUTOLCDOFF_RESET,0);
	}			
      Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
      /* Init window key mask variables & set key and key released mask */

      Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
      Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
      Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);			
    }
    else if((uiReverseGear==FALSE)&&(bCarGuideLineMode  == TRUE))
    {
        //PipView_SetStyle(PIP_STYLE_2T1B2S);
        debug_msg("---Reverse gear shitf, FALSE..\r\n");
		
        PipView_SetStyle(uiLastPipViewStyle);
        bCarGuideLineMode  = FALSE; 
        FlowMovie_UpdateIcons(TRUE);			

	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
	/* Init window key mask variables & set key and key released mask */
	g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
	g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);	
        switch(gMovData.State)
        {
          case MOV_ST_VIEW:
          case MOV_ST_VIEW|MOV_ST_ZOOM:
 		 Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
		break;
        }	
    } 
}


INT32 UIFlowWndMovie_OnTouchPanelKey(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 P1,P2;
    UINT32  uiSoundMask,uiSelect;
  
    if(paramNum>0)
	P1= paramArray[0];
    if(paramNum>1)	
	P2=paramArray[1];  
		
		    if(TPIsOnRange(&UIFlowWndMovie_Status_Main_PBCtrl,P1,P2)==TRUE)
		    	{
        			//UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_MAIN_PB_PRESSED);
				//Delay_DelayMs(500);
        			//UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_MAIN_PB);
				    switch(gMovData.State)
				    {
				      case MOV_ST_VIEW:
				      case MOV_ST_VIEW|MOV_ST_ZOOM:
				        // mask key while changing primary mode
				        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
				        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
				        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
				        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
				        // changing primary mode
					Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PLAYBACK);				        
				        break;
				    }						   
		    	}				

		    if(TPIsOnRange(&UIFlowWndMovie_Status_Main_MenuCtrl,P1,P2)==TRUE)
		    	{
        			//UxState_SetData(&UIFlowWndMovie_Status_Main_MenuCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_Menu_ICON_MAIN_MENU_PRESSED);
				//Delay_DelayMs(500);
        			//UxState_SetData(&UIFlowWndMovie_Status_Main_MenuCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_Menu_ICON_MAIN_MENU);							   
					switch(gMovData.State)
					{
						case MOV_ST_VIEW:
						case MOV_ST_VIEW|MOV_ST_ZOOM:
							//FlowMovie_UpdateIcons(TRUE);			

							// stope timer when entering menu
							if (gUIMotionDetTimerID!=NULL_TIMER)
							{
							    GxTimer_StopTimer(&gUIMotionDetTimerID);
							}

							if (g_uiDateTimerID != NULL_TIMER)
							{
							    GxTimer_StopTimer(&g_uiDateTimerID);
							}
							// enable shutter2 sound (shutter2 as OK key in menu)
							uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
							uiSoundMask |= FLGKEY_SHUTTER2;
							Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

							Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
							// Set Tab menu to Movie menu
							TM_SetMenu(&gMovieMenu);
							// Open common mix (Item + Option) menu
							Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
							gMovData.State = MOV_ST_MENU;
						break;
					}					
		    	}					    					    								    			
		    if(TPIsOnRange(&UIFlowWndMovie_Status_RECCtrl,P1,P2)==TRUE)
		    {		    
    	     			Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
		    }				
	return NVTEVT_CONSUME;
}


//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_HDR)
EVENT_END

//----------------------UIFlowWndMovie_StaticIcon_PIMCCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticIcon_PIMC)
EVENT_END

//----------------------UIFlowWndMovie_Status_GPSCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_GPS)
EVENT_END

//----------------------UIFlowWndMovie_Status_LEDCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_LED)
EVENT_END

//----------------------UIFlowWndMovie_Status_GSENSORCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_GSENSOR)
EVENT_END

//----------------------UIFlowWndMovie_Static_LockCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_Lock)
EVENT_END

//----------------------UIFlowWndMovie_Status_AudioCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Audio)
EVENT_END

//----------------------UIFlowWndMovie_Status_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_REC)
EVENT_END

//----------------------UIFlowWndMovie_Status_TimeLapesCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_TimeLapes)
EVENT_END

//----------------------UIFlowWndMovie_Status_ParkingMonitorCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_ParkingMonitor)
EVENT_END

//----------------------UIFlowWndMovie_CarNo_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_CarNo_Static)
EVENT_END

//----------------------UIFlowWndMovie_Status_ZHCarNoCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_ZHCarNo)
EVENT_END

//----------------------UIFlowWndMovie_Static_GuideCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_Guide)
EVENT_END


//----------------------UIFlowWndMovie_Status_Main_PBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Main_PB)
EVENT_END

//----------------------UIFlowWndMovie_Status_Main_MenuCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Main_Menu)
EVENT_END

